group cpp ;

document(filename, guard, namespace, enumerations, bitFields, structures, trueFlags, falseFlags) ::= <<
/**
 * \file <filename>.h
 * \note This file is generated
 *
 * Configuration:
<if(trueFlags)> *    Flags, true: <trueFlags><endif>
<if(falseFlags)> *    Flags, false : <falseFlags><endif>
 */

#ifndef <guard>_H_INCLUDED
#define <guard>_H_INCLUDED

#include \<array>
#include \<cassert>
#include \<cstdint>

namespace <namespace>
{

<bitFields>

<enumerations>

<structures>

}  // namespace <namespace>

#endif // <guard>_H_INCLUDED

>>

bitFieldType(name, description, fields, unitWidth) ::= <<

/** <description>
 */
class <name>
{
public:

   constexpr explicit <name>(uint<unitWidth>_t data) : m_data{data}
   {
   }

   constexpr operator uint<unitWidth>_t() const
   {
      return m_data;
   }

<fields:bitFieldDecl(unitWidth)>

private:
   uint<unitWidth>_t m_data;
};

>>

bitFieldDecl(field, unitWidth) ::= <<

   /** <field.name>
    *
    * <field.description>
    */
   constexpr void set<field.name>(<if(field.boolean)>bool<else>uint<unitWidth>_t<endif> val)
   {
      <if(field.boolean)>const auto mask = uint<unitWidth>_t(1U);<else>const auto mask = static_cast\<uint<unitWidth>_t>((uint<unitWidth>_t(1U) \<\< <field.width>U) - uint<unitWidth>_t(1U));
assert(val \<= mask);
<endif>


      const auto shiftedMask = mask \<\< <field.offset>U;

      m_data = (m_data & (~shiftedMask)) | (<if(field.boolean)>uint<unitWidth>_t(val)<else>val<endif> \<\< <field.offset>U);
   }

   constexpr <if(field.boolean)>bool<else>uint<unitWidth>_t<endif> get<field.name>() const
   {
      <if(field.boolean)>const auto mask = uint<unitWidth>_t(1U);<else>const auto mask = static_cast\<uint<unitWidth>_t>((uint<unitWidth>_t(1U) \<\< <field.width>U) - uint<unitWidth>_t(1U));
<endif>


      return ((m_data \>> <field.offset>U) & mask)<if(field.boolean)> != 0<endif>;
   }

>>

structure(name, description, fields, unitWidth, size) ::= <<

/** <description>
 */
class <name>
{
public:

   <fields:fieldDecl()>

private:
   std::array\<uint<unitWidth>_t, <size>\> m_data{};
};

>>

fieldDecl(field) ::= <<

   /** <field.name>
    *
    * <field.description>
    */
   constexpr void set<field.field>(<field.type> val)
   {
      const auto mask = (uint<unitWidth>_t(1U) \<\< <field.width>U) - uint<unitWidth>_t(1U);
      assert(<if(field.native)>val<else>uint<unitWidth>_t(val)<endif> \<= mask);

      const auto shiftedMask = mask \<\< <field.bitOffset>U;

      m_data[<field.unitOffset>] = (m_data[<field.unitOffset>] & (~shiftedMask)) | (<if(field.native)>val<else>uint<unitWidth>_t(val)<endif> \<\< <field.bitOffset>U);
   }

   constexpr <field.type> get<field.field>() const
   {
      const auto mask = (uint<unitWidth>_t(1U) \<\< <field.width>U) - uint<unitWidth>_t(1U);
      return <field.type>((m_data[<field.unitOffset>] \>> <field.bitOffset>U) & mask);
   }

>>
